# spring-jpa-relationships

There are 4 types of relationships in spring JPA:
- @OneToOne - This is used when 2 entities have a 1-1 mapping in the database.
- @OneToMany - This is used when 2 entities have a 1-many mapping and is used alongside many-1
- @ManyToOne
- @ManyToMany - This is used when 2 entitites have many-many mapping in the database

In every relationship type we need to set the owner of the relationships. The owner is set using the mappedBy atribute on the non-owning side of the relationship.
The value of the mappedBy attribute is the variable that will store the object in the owning side

eg: Student and Passport have a 1-1 relationship and we want to make the Student entity the owner.
In order to accomplish that we add the mappedBy atttribute to the Passport entity.

The owner is set using the following principles:

- @OneToOne - When a 1-1 mapping is present the owner can be either of the entities
- @OneToMany - When a 1-many relationship is defined it is implied that the other entity will have the many-1 annotation. The owner is the one that has the many-1 side,
because we want to store the primary key of the 1 sided entity
- @ManyToMany - When a many-many relationship is defined, the owner can be either of the entities, like in the 1-1 relationship

The @ManyToMany relationship is a special case because when we have that type of relationship,
a JoinTable is created where the database stores the relationship between the primary keys of the entities.

If we want to change the generated JoinTable name and columns we need to use the following annotations in the owning side of the relationship:
- @JoinTable - This allows us to customise the autogenerated joinTable
- @JoinColumn - This allows us to set the name of a column in the table
- name - Attribute set in @JoinTable that sets the name of the table
- joinColumns - Attribute set in @JoinTable that defines the owning side columns
- inverseJoinColumns - Attribute set in @JoinTable that defines the non-owning side columns

When fetching data from the database, each relationship has a default fetch type. The fetch type can be either EAGER or LAZY:
- EAGER - The linked data of the relationship is fetched when the initial fetch is done
- LAZY - Only the requested data is fetched

Default fetch types for relationships:
- 1-1 - EAGER
- 1-many - LAZY
- many-1 - EAGER
- many-many - LAZY

When using an entity manager to fetch data on a lazy relationship we need to add the @Transactional annotation if one has not been provided yet.

@Transactional adds all the requests in a batch and fires them at the last moment possible. The database requests are stored in a persistance context.
This way, if a database request fails, all the other requests are rolled back.

If a method has the @Transactional annotation, all the changes done to a retrieved object that is in the persistance context will be reflected in the database.

The entity manager has the following methods which affect the persistance context:
- flush() - send all the stored request to the database
- clear() - delete all the requests from the persistance context
- refresh(Obj o) - discard all the changes done to an object

Important JUnit annotations:
- @Transcational - if the test uses an entity manager and does fetch requests, the annotation is required
- @DirtiesContext - if the test changes data in the database, this annotation will undo all the changes performed
- @SpringBootTest - added to the class, tells spring that it needs to start the main application to run the test




